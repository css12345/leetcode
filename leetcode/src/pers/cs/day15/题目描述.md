	出自《IT名企算法与数据结构题目最优解》第四章递归和动态规划  最长递增子序列
	题目描述：
		 【题目】 给定数组arr，返回arr的最长递增子序列。
    		【举例】 arr=[2,1,5,3,6,4,8,9,7]，返回的最长递增子序列为[1,3,4,8,9]。
	题目链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/
	
	
	思路：使用动态规划，有两种解法，分别是O(N2)和O(NlogN).
	O(N2)解法：定义状态dp[i]表示以arr[i]结尾的最长递增子序列的长度，初始dp[0]=1.
	状态转移：对第i个元素，寻找小于它的元素中dp值最大的那个，然后加一，如果没找到，则设dp[i]=1.
	最后遍历数组，找出最大值，就是最长递增子序列的长度。
	然后是寻找序列，针对最大值的位置，寻找小于它且dp值比它小1的元素，找到后再找小于这个元素且dp值小1的
	元素，直到找完为止。
	O(NlogN)解法：后面寻找过程不变，这里是在状态转移时使用二分查找进行了优化。
	具体做法是声明了一个大小为N的ends数组，初始设置ends[0]=arr[0]，right=0，用变量right维护其有效长度，
	然后在状态转移时二分查找ends数组，找到大于等于它的值位置为pos，找到后更新ends数组该位置为新值，dp[i]=pos+1；
	如果没找到right++,ends[right]=arr[i],dp[i]=right.其他部分与O(N2)做法一致。