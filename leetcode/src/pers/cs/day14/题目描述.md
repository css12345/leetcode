	出自《IT名企算法与数据结构题目最优解》第四章递归和动态规划  换钱的方法数
	题目描述：
		 【题目】 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种 面值的货币可以使用任
	意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。
    		【举例】 arr=[5,10,25,1]，aim=0。
      	组成0元的方法有一种，就是所有面值的货币都不用。所以返回1。
    		arr=[5,10,25,1],aim=15。
    		 组成15元的方法有6种，分别为3张5元、1张10元+1张5元、1张10元+5张1 元、10张1元+1张5元、2张5元+5张1元和15张1元。所以返回6。
    		 arr=[3,5],aim=2。 任何方法都无法组成2元。所以返回0。
	题目链接：https://leetcode-cn.com/problems/coin-change-2/
	
	
	思路：1.使用暴力解法，选取第一种面值的0张，然后从剩下的面值选剩下的金额；再选第一种1张，以此类推...
	然后选第二种面值的，从0张开始，然后在剩下面值里选剩下的金额；
	2.记忆化搜索：针对暴力进行优化，将搜索过的进行存储
	3.使用动态规划：
	定义状态，与之前题目相似，现在dp[i][j]表示使用arr[0-i]达到aim的方法数。
	然后初始状态是dp[i][0]即第0列为1，dp[0][i]针对arr[0]的倍数的位置值为1，否则为0。
	状态转移，dp[i][j]=dp[i-1][j]+dp[i-1][j-arr[i]]+...+dp[i-1][j-k*arr[i]];    (1)
	意思是选取0-k张arr[i]剩下的钱数对应的方法数之和。
	这个式子即dp[i][j]=求和(dp[i-1][j-k*arr[i]]),0<=k<=j/arr[i];
	可以变形为dp[i-1][j]+求和(dp[i-1][j-k*arr[i]]),1<=k<=j/arr[i],
	令x+1=k,0<=x<=(j-arr[i])/arr[i],
	上式变为dp[i-1][j]+求和(dp[i-1][j-arr[i]-x*arr[i]]),0<=x<=(j-arr[i])/arr[i];
	根据(1)式，后者即dp[i][j-arr[i]],所以dp[i][j]=dp[i-1][j]+dp[i][j-arr[i]].
	
	最后结果是dp[arr.length-1][aim].
	