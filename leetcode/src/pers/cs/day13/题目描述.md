	出自《IT名企算法与数据结构题目最优解》第四章递归和动态规划  换钱的最少货币数 补充题目
	题目描述：
		 【补充题目】 给定数组arr，arr中所有的值都为正数。每个值仅代表一张钱的面值，再给定一个整 数aim代表要找的
		 钱数，求组成aim的最少货币数。
		 【举例】 arr=[5,2,3]，aim=20。
		 5元、2元和3元的钱各有1张，所以无法组成20元，默认返回-1。
    		arr=[5,2,5,3],aim=10。
    		5元的货币有2张，可以组成10元，且该方案所需张数最少，返回2。
    		arr=[5,2,5,3],aim=15。
    		所有的钱加起来才能组成15元，返回4。
    		arr=[5,2,5,3],aim=0。
    		不用任何货币就可以组成0元，返回0。

	
	
	思路：这道题与昨天的那道相似，不同的地方是一种面值只能用一张，同样是利用动态规划来解决。
	首先是定义状态，dp[i][j]是一个arr.length行，aim+1列的数组，dp[i][j]表示使用arr[0-i]达到j的最少货币数。
	然后是状态转移方程，首先初始状态，dp[i][0] = 0,0 <= i < arr.length;
	dp[0][i]在等于arr[0]时值为1，在其他位置值为Integer.MAX_VALUE;
	然后针对其他位置，
	1.不选arr[i],即dp[i-1][j];
	2. 选一张arr[i],这意味着前i-1张要达到j-arr[i],即dp[i-1][j-arr[i]] + 1;
	总结下来就是dp[i][j] = min(dp[i-1][j],dp[i-1][j-arr[i]]+1);
	
	最后结果是dp[arr.length-1][aim],如果值是Integer.MAX_VALUE,返回-1,否则返回值即可。