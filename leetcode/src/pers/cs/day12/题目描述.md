	出自《IT名企算法与数据结构题目最优解》第四章递归和动态规划  换钱的最少货币数
	题目描述：
		 【题目】 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种 面值的货币可以使用任
	意张，再给定一个整数aim代表要找的钱数，求组成aim的最少货 币数。
    		【举例】 arr=[5,2,3]，aim=20。
      	4张5元可以组成20元，其他的找钱方案都要使用更多张的货币，所以返回4。
    		arr=[5,2,3],aim=0。不用任何货币就可以组成0元，返回0。
           arr=[3,5],aim=2。根本无法组成2元，钱不能找开的情况下默认返回-1。
	
	
	
	思路：这道题一开始想到的是贪心算法，然后看书上是动态规划，就在网上找到了反例，当arr=[5,3,4,1],aim=7时，贪心
	算法得到的是5,1,1三张，而答案应该是3，4两张。
	首先是定义状态，dp[i][j]是一个arr.length行，aim+1列的数组，dp[i][j]表示使用arr[0-i]达到j的最少货币数。
	然后是状态转移方程，首先初始状态，dp[i][0] = 0,0 <= i < arr.length;
	dp[0][i]在arr[0]的整数倍时对应1，2，3...，在其他位置值为Integer.MAX_VALUE;
	然后针对其他位置，
	1.不选arr[i],即dp[i-1][j];
	2. 选一张arr[i],这意味着前i-1张要达到j-arr[i],即dp[i-1][j-arr[i]] + 1;
	3.选两张arr[i],即dp[i-1][j-2*arr[i]] + 2;
	4.选三张，依次类推
	总结下来就是dp[i][j] = min(dp[i-1][j-k*arr[i]] + k,k>=0);    (1)
				   = min(dp[i-1][j],dp[i-1][j-x*arr[i]] + x,x>=1)
	令x=y+1,y>=0       = min(dp[i-1][j],dp[i-1][j-arr[i] - y*arr[i]] + y + 1,y>=0)
	然后后面的dp[i-1][j-arr[i] - y*arr[i]] + y与式子(1)对比，将k换成y,j换成j-arr[i]，可以得到
	dp[i][j-arr[i]] = min(dp[i-1][j-arr[i]-y*arr[i]+y,y>=0);
	所以式子最终化为dp[i][j] = min(dp[i-1][j],dp[i][j-arr[i]]+1);
	
	最后结果是dp[arr.length-1][aim],如果值是Integer.MAX_VALUE,返回-1,否则返回值即可。