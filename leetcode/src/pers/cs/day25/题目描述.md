	出自《IT名企算法与数据结构题目最优解》第四章递归和动态规划  排成一条线的纸牌博弈问题
	题目描述：链接：https://www.nowcoder.com/questionTerminal/7036f62c64ba4104a28deee98a6f53f6
		【题目】 给定一个整型数组arr，代表分数不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或
		最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。
    		【举例】 arr=[1,2,100,4]。开始时玩家A只能拿走1或4。如果玩家A拿走1，则排列变为[2,100,4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A。如果开始时
    		玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A。玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所
    		以玩家A会先拿1，让排列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。
    		arr=[1,100,2]。开始时玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回100。
		

	思路：通过递归解决。定义递归函数f(arr,i,j)表示arr[i-j]先拿的人能拿到多少分，s(arr,i,j)表示arr[i-j]后拿的人能拿到多少分。当i==j时，说明只有一张
	牌，所以f(i,j)=arr[i],s(i,j)=0;否则对于先手，可以有两种选择，一是拿arr[i]，另一种是拿arr[j]，这样之后他就变成了后手，能拿到的分数分别
	是s(arr,i+1,j)和s(arr,i,j-1)。所以答案是Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1))。对于后手，在先手拿完后他变成了先手，此时有两种
	情况，f(arr,i+1,j)和f(arr,i,j-1)，因为之前的先手肯定会选择最优的，所以答案是Math.min(f(arr,i+1,j),f(arr,i,j-1))。最后答案是
	Math.max(f(arr,0,arr.length-1),s(arr,0,arr.length-1)),比较先手和后手能拿到的分数的最大值。
	直接递归由于复杂度太高会超时，可以使用记忆化搜索进行优化。
	
	
	还有就是采用动态规划。根据上面的关系定义两个数组f和s,f[i][j]和s[i][j]即对应上面函数。然后按列更新f和s,对于对角线元素，f为对应数组的值，s为0;对于其他
	位置，从下往上按行更新。对f,其值为Math.max(arr[i]+s[i+1][j],arr[j]+s[i][j-1]);对s,其值为Math.min(f[i+1][j],f[i][j-1])。
	最后答案为Math.max(f[0][arr.length-1],s[0][arr.length-1])。
	